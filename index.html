<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>spockhart</title>
  <meta name="description" content="a small corner of the internet for experiments, notes, and whatever i feel like shipping." />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1000px 600px at 20% 20%, rgba(120, 119, 198, .35), transparent 60%),
        radial-gradient(1000px 600px at 80% 30%, rgba(56, 189, 248, .25), transparent 60%),
        radial-gradient(1200px 700px at 50% 90%, rgba(34, 197, 94, .18), transparent 60%),
        #070712;
      color: rgba(255,255,255,.92);
      overflow: hidden;
    }

    /* subtle noise overlay */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: .06;
      mix-blend-mode: overlay;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      background-size: 220px 220px;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 28px;
      position: relative;
      z-index: 1;
    }

    .card {
      width: min(980px, calc(100vw - 56px));
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 24px;
      padding: 28px;
      box-shadow: 0 20px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      position: relative;
      overflow: hidden;
    }

    .card::after{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      border-radius: 26px;
      background: radial-gradient(700px 220px at var(--mx, 50%) var(--my, 40%), rgba(255,255,255,.12), transparent 60%);
      opacity: .8;
      mix-blend-mode: screen;
    }

    .top {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.72);
      font-size: 12px;
      background: rgba(255,255,255,.02);
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .dot {
      width: 8px; height: 8px; border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 18px rgba(34,197,94,.75);
      display: inline-block;
    }

    h1 {
      font-size: clamp(34px, 6.2vw, 64px);
      margin: 0 0 10px;
      letter-spacing: -0.03em;
      line-height: 1.05;
    }

    p {
      margin: 0 0 18px;
      color: rgba(255,255,255,.74);
      font-size: 16px;
      line-height: 1.55;
      max-width: 70ch;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 18px;
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 12px 14px;
      border-radius: 14px;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      user-select: none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover {
      transform: translateY(-2px);
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.22);
    }
    .btn:active { transform: translateY(0px) scale(.99); }
    .btn.secondary {
      background: rgba(255,255,255,.03);
    }

    .footer {
      margin-top: 18px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      color: rgba(255,255,255,.50);
      font-size: 12px;
    }

    /* ===== Modal / Game ===== */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      padding: 22px;
      z-index: 10;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
    }
    .modal.open { display: grid; }

    .panel {
      width: min(980px, calc(100vw - 36px));
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(10, 10, 20, .55);
      box-shadow: 0 30px 120px rgba(0,0,0,.7);
      overflow: hidden;
    }

    .panelTop {
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }

    .panelTitle {
      display:flex;
      flex-direction: column;
      gap: 2px;
      padding-left: 6px;
    }

    .panelTitle strong { font-size: 14px; letter-spacing: .02em; }
    .panelTitle span { font-size: 12px; color: rgba(255,255,255,.62); }

    .panelActions { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }

    .hud {
      display:flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 12px;
      color: rgba(255,255,255,.75);
    }

    .chip {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
    }

    .canvasWrap {
      padding: 14px;
    }

    canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 16/9;
      display:block;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(900px 520px at 20% 20%, rgba(120, 119, 198, .18), transparent 60%),
        radial-gradient(900px 520px at 80% 30%, rgba(56, 189, 248, .14), transparent 60%),
        radial-gradient(900px 520px at 50% 90%, rgba(34, 197, 94, .10), transparent 60%),
        rgba(0,0,0,.35);
    }

    .help {
      padding: 0 14px 14px;
      color: rgba(255,255,255,.55);
      font-size: 12px;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .kbd {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 24px;
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size: 12px;
      color: rgba(255,255,255,.8);
    }

    @media (prefers-reduced-motion: reduce) {
      .btn, .btn:hover { transition: none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <main class="card" id="card">
      <div class="top">
        <span class="tag">personal sandbox</span>
        <span class="tag mono" id="status"><span class="dot"></span>online</span>
        <span class="tag mono" id="hint">press <span class="mono">?</span></span>
      </div>

      <h1 id="title">spockhart</h1>
      <p id="blurb">
        a small corner of the internet for experiments, notes, and whatever i feel like shipping.
      </p>

      <div class="row">
        <button class="btn" id="btnPlay" type="button">üïπÔ∏è play the game</button>
        <button class="btn secondary" id="btnDo" type="button">‚ö° do something</button>
        <a class="btn secondary" href="https://github.com/johnnyshriqui" target="_blank" rel="noreferrer">üêô github</a>
      </div>

      <div class="footer">
        <div class="mono" id="time"></div>
        <div class="mono">edit <b>index.html</b> ‚Üí commit ‚Üí live</div>
      </div>
    </main>
  </div>

  <!-- Game modal -->
  <div class="modal" id="modal" aria-hidden="true">
    <div class="panel">
      <div class="panelTop">
        <div class="panelTitle">
          <strong>ORB RUSH</strong>
          <span>survive as long as you can</span>
        </div>
        <div class="panelActions">
          <div class="hud mono">
            <span class="chip">score: <span id="score">0</span></span>
            <span class="chip">best: <span id="best">0</span></span>
          </div>
          <button class="btn secondary" id="btnRestart" type="button">‚Üª restart</button>
          <button class="btn" id="btnClose" type="button">‚úï close</button>
        </div>
      </div>

      <div class="canvasWrap">
        <canvas id="game" width="1280" height="720"></canvas>
      </div>

      <div class="help">
        <div>
          move with <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> / arrows ‚Ä¢ dash with <span class="kbd">space</span>
        </div>
        <div>
          pause <span class="kbd">P</span> ‚Ä¢ close <span class="kbd">Esc</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===============================
       Landing page: alive background
    ================================ */
    const card = document.getElementById("card");
    function setCardLight(e){
      const r = card.getBoundingClientRect();
      const x = ((e.clientX - r.left) / r.width) * 100;
      const y = ((e.clientY - r.top) / r.height) * 100;
      card.style.setProperty("--mx", x + "%");
      card.style.setProperty("--my", y + "%");
    }
    document.addEventListener("mousemove", (e) => {
      // card highlight
      setCardLight(e);

      // background follows cursor (subtle premium effect)
      const x = (e.clientX / window.innerWidth) * 100;
      const y = (e.clientY / window.innerHeight) * 100;
      document.body.style.background = `
        radial-gradient(1000px 600px at ${x}% ${y}%, rgba(120, 119, 198, .35), transparent 60%),
        radial-gradient(1000px 600px at ${100 - x}% ${y}%, rgba(56, 189, 248, .25), transparent 60%),
        radial-gradient(1200px 700px at 50% 90%, rgba(34, 197, 94, .18), transparent 60%),
        #070712
      `;
    });

    // clock
    function tick() {
      const d = new Date();
      document.getElementById("time").textContent = d.toLocaleString();
    }
    tick();
    setInterval(tick, 1000);

    // devtools easter egg
    console.log(
      "%cspockhart online ‚ö°\n%cif you're reading this, you‚Äôre the right kind of person.",
      "color:#22c55e;font-size:16px;font-weight:bold",
      "color:#aaa"
    );

    // micro-glitch button
    const titleEl = document.getElementById("title");
    const blurbEl = document.getElementById("blurb");
    document.getElementById("btnDo").addEventListener("click", () => {
      const originalT = titleEl.textContent;
      const originalP = blurbEl.textContent;

      card.animate(
        [
          { filter: "blur(0px)", transform: "scale(1)" },
          { filter: "blur(1.8px)", transform: "scale(1.01) rotate(0.4deg)" },
          { filter: "blur(0px)", transform: "scale(1)" }
        ],
        { duration: 320, easing: "ease-out" }
      );

      const scramble = (s) => s.split("").map(ch => {
        if (ch === " ") return " ";
        return Math.random() > 0.72 ? "‚ñà" : ch;
      }).join("");

      titleEl.textContent = scramble(originalT);
      blurbEl.textContent = scramble(originalP);

      setTimeout(() => {
        titleEl.textContent = originalT;
        blurbEl.textContent = originalP;
      }, 320);
    });

    // secret help
    document.addEventListener("keydown", (e) => {
      if (e.key === "?") alert("secret: press P to pause the game üëÄ");
      if (e.key.toLowerCase() === "g") window.open("https://github.com/johnnyshriqui", "_blank");
    });

    /* ===============================
       Game: ORB RUSH (Canvas)
       - you are a glowing orb
       - enemies spawn from edges and hunt you
       - survive, score rises, difficulty ramps
       - dash (space) with cooldown
    ================================ */
    const modal = document.getElementById("modal");
    const btnPlay = document.getElementById("btnPlay");
    const btnClose = document.getElementById("btnClose");
    const btnRestart = document.getElementById("btnRestart");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Use fixed internal resolution (canvas width/height) and scale via CSS.
    const W = canvas.width;
    const H = canvas.height;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const len = (x,y) => Math.hypot(x,y);

    let keys = new Set();
    let raf = null;

    let state = null;

    function loadBest(){
      const v = Number(localStorage.getItem("orb_rush_best") || "0");
      return Number.isFinite(v) ? v : 0;
    }
    function saveBest(v){
      localStorage.setItem("orb_rush_best", String(v));
    }

    function openGame(){
      modal.classList.add("open");
      modal.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
      start(true);
    }

    function closeGame(){
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "hidden"; // body already hidden for background; keep consistent
      stopLoop();
      keys.clear();
    }

    btnPlay.addEventListener("click", openGame);
    btnClose.addEventListener("click", closeGame);
    btnRestart.addEventListener("click", () => start(true));

    window.addEventListener("keydown", (e) => {
      if (modal.classList.contains("open")) {
        if (e.key === "Escape") { e.preventDefault(); closeGame(); return; }
        if (e.key.toLowerCase() === "p") { e.preventDefault(); state.paused = !state.paused; return; }
        if (e.key === " ") e.preventDefault(); // prevent page scroll
      }
      keys.add(e.key.toLowerCase());
    });

    window.addEventListener("keyup", (e) => {
      keys.delete(e.key.toLowerCase());
    });

    // Clicking outside panel closes
    modal.addEventListener("mousedown", (e) => {
      if (e.target === modal) closeGame();
    });

    function start(resetBestDisplay = false){
      stopLoop();

      const best = loadBest();
      if (resetBestDisplay) bestEl.textContent = best;

      state = {
        t: 0,
        last: performance.now(),
        score: 0,
        best,
        over: false,
        paused: false,

        player: {
          x: W * 0.5,
          y: H * 0.5,
          r: 12,
          vx: 0,
          vy: 0,
          baseSpeed: 360,
          dashSpeed: 900,
          dashTime: 0,
          dashCd: 0
        },

        enemies: [],
        particles: [],
        spawnTimer: 0,
        spawnInterval: 0.95, // seconds
        difficulty: 1
      };

      scoreEl.textContent = "0";

      raf = requestAnimationFrame(loop);
    }

    function stopLoop(){
      if (raf) cancelAnimationFrame(raf);
      raf = null;
    }

    function loop(now){
      raf = requestAnimationFrame(loop);

      if (!state) return;
      const dt = Math.min(0.033, (now - state.last) / 1000);
      state.last = now;

      if (state.paused) {
        draw();
        drawOverlay("paused", "press P to resume");
        return;
      }

      if (!state.over) update(dt);
      draw();

      if (state.over) {
        drawOverlay("game over", "press ‚Üª restart or Esc");
      }
    }

    function update(dt){
      state.t += dt;

      // score ramps with time + difficulty
      state.difficulty = 1 + state.t / 18;
      state.score = Math.floor(state.t * 100);
      scoreEl.textContent = String(state.score);

      // best
      if (state.score > state.best) {
        state.best = state.score;
        bestEl.textContent = String(state.best);
        saveBest(state.best);
      }

      const p = state.player;

      // movement input
      let ix = 0, iy = 0;
      const k = keys;

      if (k.has("a") || k.has("arrowleft")) ix -= 1;
      if (k.has("d") || k.has("arrowright")) ix += 1;
      if (k.has("w") || k.has("arrowup")) iy -= 1;
      if (k.has("s") || k.has("arrowdown")) iy += 1;

      const mag = Math.hypot(ix, iy) || 1;
      ix /= mag; iy /= mag;

      // dash
      p.dashCd = Math.max(0, p.dashCd - dt);
      p.dashTime = Math.max(0, p.dashTime - dt);

      const wantDash = k.has(" ");
      if (wantDash && p.dashCd <= 0 && (ix !== 0 || iy !== 0)) {
        p.dashTime = 0.12;
        p.dashCd = 0.85;
        // burst particles
        for (let i=0;i<18;i++){
          spawnParticle(p.x, p.y, (Math.random()*2-1)*260, (Math.random()*2-1)*260, 0.35, 2.2);
        }
      }

      const speed = (p.dashTime > 0) ? p.dashSpeed : p.baseSpeed;

      // smooth velocity
      const targetVx = ix * speed;
      const targetVy = iy * speed;
      const accel = (p.dashTime > 0) ? 18 : 12;
      p.vx += (targetVx - p.vx) * (1 - Math.exp(-accel * dt));
      p.vy += (targetVy - p.vy) * (1 - Math.exp(-accel * dt));

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // keep in bounds
      p.x = clamp(p.x, p.r + 8, W - p.r - 8);
      p.y = clamp(p.y, p.r + 8, H - p.r - 8);

      // enemy spawns
      state.spawnInterval = Math.max(0.22, 0.95 / (state.difficulty));
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        state.spawnTimer = state.spawnInterval * (0.85 + Math.random()*0.3);
        spawnEnemy();
      }

      // update enemies (seek player)
      const enemies = state.enemies;
      for (let i=enemies.length-1; i>=0; i--){
        const e = enemies[i];
        const dx = p.x - e.x;
        const dy = p.y - e.y;
        const d = Math.hypot(dx, dy) || 1;

        // seek strength + slight orbit wobble
        const seek = e.speed;
        const nx = dx / d, ny = dy / d;

        // wobble to feel organic
        e.w += dt * e.wr;
        const wobx = Math.cos(e.w) * 0.18;
        const woby = Math.sin(e.w) * 0.18;

        e.vx += (nx * seek + wobx*seek - e.vx) * (1 - Math.exp(-8*dt));
        e.vy += (ny * seek + woby*seek - e.vy) * (1 - Math.exp(-8*dt));

        e.x += e.vx * dt;
        e.y += e.vy * dt;

        // particles trail
        if (Math.random() < 0.6) spawnParticle(e.x, e.y, -e.vx*0.05, -e.vy*0.05, 0.22, 1.7);

        // collision
        if (d < p.r + e.r) {
          state.over = true;
          // explode
          for (let j=0;j<70;j++){
            spawnParticle(p.x, p.y, (Math.random()*2-1)*420, (Math.random()*2-1)*420, 0.7, 2.6);
          }
          break;
        }

        // cull far-out enemies (rare)
        if (e.x < -200 || e.x > W+200 || e.y < -200 || e.y > H+200) {
          enemies.splice(i, 1);
        }
      }

      // update particles
      const parts = state.particles;
      for (let i=parts.length-1;i>=0;i--){
        const pr = parts[i];
        pr.t -= dt;
        pr.x += pr.vx * dt;
        pr.y += pr.vy * dt;
        pr.vx *= Math.exp(-2.8*dt);
        pr.vy *= Math.exp(-2.8*dt);
        if (pr.t <= 0) parts.splice(i,1);
      }
    }

    function spawnEnemy(){
      const side = Math.floor(Math.random()*4);
      const pad = 40;

      let x, y;
      if (side === 0) { x = -pad; y = Math.random()*H; }          // left
      if (side === 1) { x = W+pad; y = Math.random()*H; }         // right
      if (side === 2) { x = Math.random()*W; y = -pad; }          // top
      if (side === 3) { x = Math.random()*W; y = H+pad; }         // bottom

      const r = 10 + Math.random()*8;
      const speed = 160 + state.difficulty*45 + Math.random()*60;

      state.enemies.push({
        x, y,
        r,
        vx: 0, vy: 0,
        speed,
        w: Math.random()*10,
        wr: 2 + Math.random()*4
      });
    }

    function spawnParticle(x,y,vx,vy,t,r){
      state.particles.push({ x,y,vx,vy,t,tt:t, r });
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,W,H);

      // soft vignette
      ctx.save();
      ctx.globalAlpha = 0.9;
      const g = ctx.createRadialGradient(W/2,H/2, 10, W/2,H/2, Math.max(W,H)/1.05);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      // subtle star specks (procedural)
      ctx.save();
      ctx.globalAlpha = 0.32;
      for (let i=0;i<70;i++){
        const sx = (i*199 + Math.floor(state.t*40)) % W;
        const sy = (i*347 + Math.floor(state.t*18)) % H;
        ctx.fillRect(sx, sy, 1, 1);
      }
      ctx.restore();

      // particles
      ctx.save();
      for (const pr of state.particles){
        const a = Math.max(0, pr.t / pr.tt);
        ctx.globalAlpha = a * 0.9;
        ctx.beginPath();
        ctx.arc(pr.x, pr.y, pr.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // enemies (glow rings)
      ctx.save();
      for (const e of state.enemies){
        // outer glow
        ctx.globalAlpha = 0.18;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r*2.2, 0, Math.PI*2);
        ctx.fill();

        // core
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // player (bright)
      const p = state.player;
      ctx.save();
      // player aura
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*3.0, 0, Math.PI*2);
      ctx.fill();

      // player ring
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();

      // dash indicator
      if (p.dashCd > 0){
        const cd = clamp(p.dashCd / 0.85, 0, 1);
        ctx.globalAlpha = 0.45;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r + 10, -Math.PI/2, -Math.PI/2 + (1-cd)*Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();

      // top-left tiny text
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      const msg = state.over ? "crashed" : (state.paused ? "paused" : "survive");
      ctx.fillText(msg, 18, 26);
      ctx.restore();
    }

    function drawOverlay(title, subtitle){
      ctx.save();
      ctx.globalAlpha = 0.65;
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;

      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "700 54px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText(title, W/2, H/2 - 10);

      ctx.fillStyle = "rgba(255,255,255,.68)";
      ctx.font = "16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillText(subtitle, W/2, H/2 + 26);
      ctx.restore();
    }

    // Close on resize? No‚Äîjust keep it stable.
    // But we can keep pointer highlight stable.
    card.addEventListener("mousemove", setCardLight);

    // Prevent background scroll on mobile when modal open
    document.addEventListener("touchmove", (e) => {
      if (modal.classList.contains("open")) e.preventDefault();
    }, { passive: false });

  </script>
</body>
</html>
